// Sort : NTree -> NTree
(Sort t) = (STree.back (STree.make t))

// STree.merge : STree -> STree -> STree
(STree.merge Free       Free)       = Free
(STree.merge Free       Used)       = Used
(STree.merge Used       Free)       = Used
(STree.merge Used       Used)       = Used
(STree.merge Free       (Both c d)) = (Both c d)
(STree.merge (Both a b) Free)       = (Both a b)
(STree.merge (Both a b) (Both c d)) = (Both (STree.merge a c) (STree.merge b d))

// STree.make : NTree -> STree
(STree.make Null)       = Free
(STree.make (Leaf a))   = (STree.word a)
(STree.make (Node a b)) = (STree.merge (STree.make a) (STree.make b))

// STree.back : STree -> NTree
(STree.back t) = (STree.back.go 0 t)
  (STree.back.go x Free) = Null
  (STree.back.go x Used) = (Leaf x)
  (STree.back.go x (Both a b)) =
    let x = (<< x 1)
    let y = (| x 1)
    let a = (STree.back.go x a)
    let b = (STree.back.go y b)
    (Node a b)

// STree.word : U60 -> STree
(STree.word n) =
  let r = Used
  let r = (U60.swap (& n 1) r Free)
  let r = (U60.swap (& n 2) r Free)
  let r = (U60.swap (& n 4) r Free)
  let r = (U60.swap (& n 8) r Free)
  let r = (U60.swap (& n 16) r Free)
  let r = (U60.swap (& n 32) r Free)
  let r = (U60.swap (& n 64) r Free)
  let r = (U60.swap (& n 128) r Free)
  let r = (U60.swap (& n 256) r Free)
  let r = (U60.swap (& n 512) r Free)
  let r = (U60.swap (& n 1024) r Free)
  let r = (U60.swap (& n 2048) r Free)
  let r = (U60.swap (& n 4096) r Free)
  let r = (U60.swap (& n 8192) r Free)
  let r = (U60.swap (& n 16384) r Free)
  let r = (U60.swap (& n 32768) r Free)
  let r = (U60.swap (& n 65536) r Free)
  let r = (U60.swap (& n 131072) r Free)
  let r = (U60.swap (& n 262144) r Free)
  let r = (U60.swap (& n 524288) r Free)
  let r = (U60.swap (& n 1048576) r Free)
  let r = (U60.swap (& n 2097152) r Free)
  let r = (U60.swap (& n 4194304) r Free)
  let r = (U60.swap (& n 8388608) r Free)
  r

// This is hardcoded by HVM:
// (U60.swap 0 a b) = (Both a b)
// (U60.swap n a b) = (Both b a)

// Reverse : NTree -> NTree
(Reverse Null)       = Null
(Reverse (Leaf a))   = (Leaf a)
(Reverse (Node a b)) = (Node (Reverse b) (Reverse a))

// Sum : NTree -> U60
(Sum Null)       = 0
(Sum (Leaf x))   = x
(Sum (Node a b)) = (+ (Sum a) (Sum b))

// Gen : U60 -> NTree
(Gen n) = (Gen.go n 0)
  (Gen.go 0 x) = (Leaf x)
  (Gen.go n x) =
    let x = (<< x 1)
    let y = (| x 1)
    let n = (- n 1)
    (Node (Gen.go n x) (Gen.go n y))

(Main n) = (Sum (Sort (Reverse (Gen 24))))

// STree.from_num : U60 -> STree
//(STree.from_num n) = (STree.from_num.go 24 n Used)
  //(STree.from_num.go 0 n r) = r
  //(STree.from_num.go s n r) = (STree.from_num.go (- s 1) (>> n 1) (STree.from_num.mk (& n 1) r))
  //(STree.from_num.mk 0 r)   = (Both r Free)
  //(STree.from_num.mk 1 r)   = (Both Free r)
